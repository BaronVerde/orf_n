
#pragma once

#include <noise/Billow.h>
#include <noise/Perlin.h>
#include <noise/RidgeMulti.h>
#include <noise/Selector.h>
#include <noise/Turbulence.h>
#include <fstream>
#include <limits>
#include <stdexcept>
#include <png++/image.hpp>
#include <png++/gray_pixel.hpp>

namespace noise {

/// The maximum width of a map.
const uint16_t MAX_MAP_WIDTH{ 32767 };

/// The maximum height of a map.
const uint16_t MAX_MAP_HEIGHT{ 32767 };

const double DEFAULT_METRES_PER_POINT{ 30.0 };

/// Implements a noise map, a 2-dimensional array of floating-point values.
///
/// A noise map is designed to store coherent-noise values generated by a
/// noise module, although it can store values from any source.  A noise
/// map is often used as a terrain height map or a grayscale texture.
///
/// The size (width and height) of the noise map can be specified during
/// object construction or at any other time.
///
/// The GetValue() and SetValue() methods can be used to access individual
/// values stored in the noise map.
///
/// This class manages its own memory.  If you copy a noise map object
/// into another noise map object, the original contents of the noise map
/// object will be freed.
///
/// If you specify a new size for the noise map and the new size is
/// smaller than the current size, the allocated memory will not be
/// reallocated.
/// Call ReclaimMem() to reclaim the wasted memory.
///
/// <b>Border Values</b>
///
/// All of the values outside of the noise map are assumed to have a
/// common value known as the <i>border value</i>.
///
/// To set the border value, call the SetBorderValue() method.
///
/// The GetValue() method returns the border value if the specified value
/// lies outside of the noise map.
///
/// <b>Internal Noise Map Structure</b>
///
/// Internally, the values are organized into horizontal rows called @a
/// slabs.  Slabs are ordered from bottom to top.
///
/// Each slab contains a contiguous row of values in memory.  The values
/// in a slab are organized left to right.
///
/// The offset between the starting points of any two adjacent slabs is
/// called the <i>stride amount</i>.  The stride amount is measured by
/// the number of @a float values between these two starting points, not
/// by the number of bytes.  For efficiency reasons, the stride is often a
/// multiple of the machine word size.
///
/// The GetSlabPtr() and GetConstSlabPtr() methods allow you to retrieve
/// pointers to the slabs themselves.
class NoiseMap {
public:
	/// Creates a Noise Map
	/// @param width The width of the new noise map.
	/// @param height The height of the new noise map.
	///
	/// @pre The width and height values are positive.
	/// @pre The width and height values do not exceed the maximum
	/// possible width and height for the noise map.
	/// Axes are switched here to be able to address the map with x/y coords
	NoiseMap( const uint16_t width, const uint16_t height ) :
		m_width{width}, m_height{height}, m_sizeInBytes{ m_width * m_height * sizeof( double ) } {
		m_values = new double *[m_width];
		for( int i{0}; i < m_width; ++i )
			m_values[i] = new double[m_height];
		std::cout << "Map created. Size in memory " << m_sizeInBytes / 1024 << "kb.\n";
	}

	virtual ~NoiseMap() {
		for( int i{0}; i < m_width; ++i )
			delete [] m_values[i];
		delete [] m_values;
	}

	// No bounds checking !
	void setValue( const uint16_t x, const uint16_t y, const double value ) {
		m_values[x][y] = value;
	}

	void printData() {
		for( uint16_t x{0}; x < m_width; ++x ) {
			for( uint16_t y{0}; y < m_width; ++y )
				std::cout << m_values[x][y] << ' ';
			std::cout << '\n';
		}
	}

	const double &getValue( const uint16_t x, const uint16_t y, const double value ) const {
		return m_values[x][y];
	}

	uint16_t getWidth() const {
		return m_width;
	}

	uint16_t getHeight() const {
		return m_height;
	}

	// Returns minumum and maximum values of the map.
	// Can be used to calculate offset and scale for the output file to 16 bit integer
	void getMinMaxValues( double &min, double &max ) const {
		min = std::numeric_limits<double>::max();
		max = std::numeric_limits<double>::min();
		for( uint16_t x{0}; x < m_width; ++x ) {
			for( uint16_t y{0}; y < m_height; ++y ) {
				if( min > m_values[x][y] )
					min = m_values[x][y];
				if( max < m_values[x][y] )
					max = m_values[x][y];
			}
		}
	}

	// Image starts at the lower left.
	// Values are usually around +/-0.0. Offset and scale should straddle them
	// to 16 bit unsigned int range.
	void writePNG( const std::string &filename, const double offset = 0, const double scale = 1.0f ) const {
		png::image<png::gray_pixel_16> image{ (uint32_t)m_width, (uint32_t)m_height };
		std::cout << "PNG image created. Size in memory " << m_width * m_height * sizeof( uint16_t ) / 1024 << "kb.\n";
		for( uint16_t x{0}; x < m_width; ++x ) {
			for( uint16_t y{0}; y < m_height; ++y ) {
				double value{ ( m_values[x][y] + offset ) * scale };
				image[m_height-y-1][x] = png::gray_pixel_16{ (uint16_t)value };
			}
		}
		image.write( filename );
	}

private:
	uint16_t m_width;

	uint16_t m_height;

	size_t m_sizeInBytes;

	double **m_values;

};

/// A builder class builds a noise map by filling it with coherent-noise
/// values generated from the surface of a three-dimensional mathematical
/// object.  Each builder class defines a specific three-dimensional
/// surface, such as a cylinder, sphere, or plane.
///
/// A builder class describes these input values using a coordinate system
/// applicable for the mathematical object (e.g., a latitude/longitude
/// coordinate system for the spherical noise-map builder.)  It then
/// "flattens" these coordinates onto a plane so that it can write the
/// coherent-noise values into a two-dimensional noise map.
///
/// <b>Building the Noise Map</b>
///
/// To build the noise map, perform the following steps:
/// - Pass the bounding coordinates to the SetBounds() method.
/// - Pass the noise map size, in points, to the SetDestSize() method.
/// - Pass a NoiseMap object to the SetDestNoiseMap() method.
/// - Pass a noise module (derived from noise::module::Module) to the
///   SetSourceModule() method.
/// - Call the Build() method.
///
/// You may also pass a callback function to the SetCallback() method.
/// The Build() method calls this callback function each time it fills a
/// row of the noise map with coherent-noise values.  This callback
/// function has a single integer parameter that contains a count of the
/// rows that have been completed.  It returns void.
///
/// Note that SetBounds() is not defined in the abstract base class; it is
/// only defined in the derived classes.  This is because each model uses
/// a different coordinate system.
/// Builds a planar noise map.
///
/// This class builds a noise map by filling it with coherent-noise values
/// generated from the surface of a plane.
///
/// This class describes these input values using (x, z) coordinates.
/// Their y coordinates are always 0.0.
///
/// The application must provide the lower and upper x coordinate bounds
/// of the noise map, in units, and the lower and upper z coordinate
/// bounds of the noise map, in units.
///
/// To make a tileable noise map with no seams at the edges, call the
/// EnableSeamless() method.
class MapBuilderPlane {
public:
	MapBuilderPlane( const BaseNoise *source,
					 NoiseMap *map,
					 const double lowerX,
					 const double lowerZ,
					 const double upperX,
					 const double upperZ,
					 const bool enableSeamless = false ) :
						 m_source{source}, m_noiseMap{map}, m_lowerX{lowerX}, m_lowerZ{lowerZ},
						 m_upperX{upperX}, m_upperZ{upperZ}, m_enableSeamless{enableSeamless} {
		// check
		if( m_upperX <= m_lowerX || m_upperZ <= m_lowerZ || m_source == nullptr || m_noiseMap == nullptr )
			throw std::runtime_error( "Parameter error building planar map." );
		uint16_t w{ m_noiseMap->getWidth() };
		uint16_t h{ m_noiseMap->getHeight() };
		const double xExtent{ m_upperX - m_lowerX };
		const double zExtent{ m_upperZ - m_lowerZ };
		const double xDelta{ xExtent / (double)w };
		const double zDelta{ zExtent / (double)h };
		double xCur{ m_lowerX };
		double zCur{ m_lowerZ };
		// Fill every point in the noise map with the output values from the model.
		for( uint16_t z{0}; z < h; ++z ) {
			xCur = m_lowerX;
			for( uint16_t x{0}; x < w; ++x ) {
				float finalValue;
				if( !m_enableSeamless )
					finalValue = m_source->getValue( xCur, 0.0, zCur );
				else {
					const double swValue{ m_source->getValue( xCur, 0.0, zCur ) };
					const double seValue{ m_source->getValue( xCur + xExtent, 0.0, zCur ) };
					const double nwValue{ m_source->getValue( xCur, 0.0, zCur + zExtent ) };
					const double neValue{ m_source->getValue( xCur + xExtent, 0.0, zCur + zExtent ) };
					const double xBlend{ 1.0 - ( ( xCur - m_lowerX ) / xExtent ) };
					const double zBlend{ 1.0 - ( ( zCur - m_lowerZ ) / zExtent ) };
					const double z0{ noiselerp( swValue, seValue, xBlend ) };
					const double z1{ noiselerp( nwValue, neValue, xBlend ) };
					finalValue = (float)noiselerp( z0, z1, zBlend );
				}
				m_noiseMap->setValue( x, z, finalValue );
				xCur += xDelta;
			}
		    zCur += zDelta;
		}
	}

private:
	const BaseNoise *m_source{ nullptr };

	NoiseMap *m_noiseMap{ nullptr };

	const double m_lowerX{0};

	const double m_lowerZ{0};

	const double m_upperX{0};

	const double m_upperZ{0};

	bool m_enableSeamless{ false };

};

class MapBuilderSphere {
public:
	MapBuilderSphere( const BaseNoise *source,
					  NoiseMap *map,
					  const double northLat,
					  const double southLat,
					  const double eastLon,
					  const double westLon,
					  const bool enableSeamless = false ) :
						  m_source{source}, m_noiseMap{map},
						  m_northLat{northLat}, m_southLat{southLat}, m_eastLon{eastLon}, m_westLon{westLon},
						  m_enableSeamless{enableSeamless} {
		if( m_eastLon <= m_westLon || m_northLat <= m_southLat || source == nullptr || map == nullptr )
			throw std::runtime_error( "Parameter error in sphere map builder" );
		// Create the plane model.
		const double lonExtent{ m_eastLon - m_westLon };
		const double latExtent{ m_northLat - m_southLat };
		const double xDelta{ lonExtent / (double)m_noiseMap->getWidth() };
		const double yDelta{ latExtent / (double)m_noiseMap->getHeight() };
		double curLon{ m_westLon };
		double curLat{ m_southLat };
		// Fill every point in the noise map with the output values from the model.
		for( int h{0}; h < m_noiseMap->getHeight(); ++h ) {
			curLon = m_westLon;
			for( int w{0}; w < m_noiseMap->getWidth(); ++w ) {
				double x, y, z;
				latLonToXYZ( curLat, curLon, x, y, z );
				m_noiseMap->setValue( w, h, m_source->getValue( x, y, z ) );
				curLon += xDelta;
			}
			curLat += yDelta;
		}
	}

private:
	const BaseNoise *m_source{ nullptr };

	NoiseMap *m_noiseMap{ nullptr };

	const double m_northLat;

	const double m_southLat;

	const double m_eastLon;

	const double m_westLon;

	bool m_enableSeamless{ false };

};

}
